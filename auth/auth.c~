/* Authentication server.
   Copyright (C) 1996,97,98,99,2002 Free Software Foundation, Inc.
   Written by Roland McGrath.

   This file is part of the GNU Hurd.

   The GNU Hurd is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2, or (at
   your option) any later version.

   The GNU Hurd is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <mach.h>
#include <cthreads.h>
#include <hurd.h>
#include <hurd/startup.h>
#include <hurd/ports.h>
#include <hurd/ihash.h>
#include <idvec.h>
#include <assert.h>
#include <argp.h>
#include <error.h>
#include <version.h>
#include "auth_S.h"
#include "auth_reply_U.h"

const char *argp_program_version = STANDARD_HURD_VERSION(auth);


/* Auth handles are server ports with sets of ids.  */
struct authhandle
  {
    struct port_info pi;
    struct idvec euids, egids, auids, agids;
  };

struct port_bucket *auth_bucket;
struct port_class *authhandle_portclass;


/* Create a new auth port.  */

static error_t
create_authhandle (struct authhandle **new)
{
  error_t err = ports_create_port (authhandle_portclass, auth_bucket,
				   sizeof **new, new);
  if (! err)
    bzero (&(*new)->euids, (void *) &(*new)[1] - (void *) &(*new)->euids);
  return err;
}

/* Clean up a dead auth port.  */

static void
destroy_authhandle (void *p)
{
  struct authhandle *h = p;
  idvec_free_contents (&h->euids);
  idvec_free_contents (&h->egids);
  idvec_free_contents (&h->auids);
  idvec_free_contents (&h->agids);
}

/* Called by server stub functions.  */

authhandle_t
auth_port_to_handle (auth_t auth)
{
  return ports_lookup_port (auth_bucket, auth, authhandle_portclass);
}

/* id management.  */

static inline void
idvec_copyout (struct idvec *idvec, uid_t **ids, size_t *nids)
{
  if (idvec->num > *nids)
    *ids = idvec->ids;
  else
    memcpy (*ids, idvec->ids, idvec->num * sizeof *ids);
  *nids = idvec->num;
}

#define C(auth, ids)	idvec_copyout (&auth->ids, ids, n##ids)
#define OUTIDS(auth)	(C (auth, euids), C (auth, egids), \
			 C (auth, auids), C (auth, agids))

/* Implement auth_getids as described in <hurd/auth.defs>. */
kern_return_t
S_auth_getids (struct authhandle *auth,
	       uid_t **euids,
	       size_t *neuids,
	       uid_t **auids,
	       size_t *nauids,
	       uid_t **egids,
	       size_t *negids,
	       uid_t **agids,
	       size_t *nagids)
{
  if (! auth)
    return EOPNOTSUPP;

  OUTIDS (auth);

  return 0;
}

/* Implement auth_makeauth as described in <hurd/auth.defs>. */
kern_return_t
S_auth_makeauth (struct authhandle *auth,
		 mach_port_t *authpts, size_t nauths,
		 uid_t *euids, size_t neuids,
		 uid_t *auids, size_t nauids,
		 uid_t *egids, size_t negids,
		 uid_t *agids, size_t nagids,
		 mach_port_t *newhandle)
{
  struct authhandle *newauth, *auths[1 + nauths];
  int hasroot = 0;
  error_t err;
  size_t i, j;

  if (!auth)
    return EOPNOTSUPP;

  auths[0] = auth;

  /* Fetch the auth structures for all the ports passed in. */
  for (i = 0; i < nauths; i++)
    auths[i + 1] = auth_port_to_handle (authpts[i]);

  ++nauths;

  /* Verify that the union of the handles passed in either contains euid 0
     (root), or contains all the requested ids.  */

#define isuid(uid, auth) \
  (idvec_contains (&(auth)->euids, uid) \
   || idvec_contains (&(auth)->auids, uid))
#define groupmember(gid, auth) \
  (idvec_contains (&(auth)->egids, gid) \
   || idvec_contains (&(auth)->agids, gid))
#define isroot(auth)		isuid (0, auth)

  for (i = 0; i < nauths; i++)
    if (auths[i] && isroot (auths[i]))
      {
	hasroot = 1;
	break;
      }

  if (!hasroot)
    {
      int has_it;

      for (i = 0; i < neuids; i++)
	{
	  has_it = 0;
	  for (j = 0; j < nauths; j++)
	    if (auths[j] && isuid (euids[i], auths[j]))
	      {
		has_it = 1;
		break;
	      }
	  if (!has_it)
	    goto eperm;
	}

      for (i = 0; i < nauids; i++)
	{
	  has_it = 0;
	  for (j = 0; j < nauths; j++)
	    if (auths[j] && isuid (auids[i], auths[j]))
	      {
		has_it = 1;
		break;
	      }
	  if (!has_it)
	    goto eperm;
	}

      for (i = 0; i < negids; i++)
	{
	  has_it = 0;
	  for (j = 0; j < nauths; j++)
	    if (auths[j] && groupmember (egids[i], auths[j]))
	      {
		has_it = 1;
		break;
	      }
	  if (!has_it)
	    goto eperm;
	}

      for (i = 0; i < nagids; i++)
	{
	  has_it = 0;
	  for (j = 0; j < nauths; j++)
	    if (auths[j] && groupmember (agids[i], auths[j]))
	      {
		has_it = 1;
		break;
	      }
	  if (!has_it)
	    goto eperm;
	}
    }

  err = create_authhandle (&newauth);

  /* Create a new handle with the specified ids.  */

#define MERGE S (euids); S (egids); S (auids); S (agids);
#define S(uids) if (!err) err = idvec_merge_ids (&newauth->uids, uids, n##uids)

  MERGE;

#undef S

  if (! err)
    {
      for (j = 1; j < nauths; ++j)
	mach_port_deallocate (mach_task_self (), authpts[j - 1]);
      *newhandle = ports_get_right (newauth);
      ports_port_deref (newauth);
    }

  for (j = 1; j < nauths; j++)
    if (auths[j])
      ports_port_deref (auths[j]);
  return err;

 eperm:
  for (j = 1; j < nauths; j++)
    if (auths[j])
      ports_port_deref (auths[j]);
  return EPERM;
}

/* Transaction handling.  */

/* A pending transaction.  */
struct pending
  {
    hurd_ihash_locp_t locp;	/* Position in one of the ihash tables.  */
    struct condition wakeup;    /* The waiter is blocked on this condition.  */

    /* The user's auth handle.  */
    struct authhandle *user;

    /* The port to pass back to the user.  */
    mach_port_t passthrough;
  };

/* Table of pending transactions keyed on RENDEZVOUS.  */
struct hurd_ihash pending_users
  = HURD_IHASH_INITIALIZER (offsetof (struct pending, locp));
struct hurd_ihash pending_servers
  = HURD_IHASH_INITIALIZER (offsetof (struct pending, locp));
struct mutex pending_lock = MUTEX_INITIALIZER;

/* Implement auth_user_authenticate as described in <hurd/auth.defs>. */
kern_return_t
S_auth_user_authenticate (struct authhandle *userauth,
			  mach_port_t reply,
			  mach_msg_type_name_t reply_type,
			  mach_port_t rendezvous,
			  mach_port_t *newport,
			  mach_msg_type_name_t *newporttype)
{
  struct pending *s;

  if (! userauth)
    return EOPNOTSUPP;

  if (rendezvous == MACH_PORT_DEAD) /* Port died in transit.  */
    return EINVAL;

  mutex_lock (&pending_lock);

  /* Look for this port in the server list.  */
  s = hurd_ihash_find (&pending_servers, rendezvous);
  if (s)
    {
      /* Found it!  Extract the port.  */
      *newport = s->passthrough;
      *newporttype = MACH_MSG_TYPE_MOVE_SEND;

      /* Remove it from the pending list.  */
      hurd_ihash_locp_remove (&pending_servers, s->locp);

      /* Give the server the auth port and wake the RPC up.
	 We need to add a ref in case the port dies.  */
      s->user = userauth;
      ports_port_ref (userauth);

      condition_signal (&s->wakeup);
      mutex_unlock (&pending_lock);

      mach_port_deallocate (mach_task_self (), rendezvous);
      return 0;
    }
  else
    {
      /* No pending server RPC for this port.
	 Create a pending user RPC record.  */
      struct pending u;
      error_t err;

      err = hurd_ihash_add (&pending_users, rendezvous, &u);
      if (! err)
	{
	  /* Store the user auth port and wait for the server RPC to wake
             us up.  */
	  u.user = userauth;
	  condition_init (&u.wakeup);
	  ports_interrupt_self_on_port_death (userauth, rendezvous);
	  if (hurd_condition_wait (&u.wakeup, &pending_lock))
	    /* We were interrupted; remove our record.  */
	    {
	      hurd_ihash_locp_remove (&pending_users, u.locp);
	      err = EINTR;
	    }
	}
      /* The server side has already removed U from the ihash table.  */
      mutex_unlock (&pending_lock);

      if (! err)
	{
	  /* The server RPC has set the port and signalled U.wakeup.  */
	  *newport = u.passthrough;
	  *newporttype = MACH_MSG_TYPE_MOVE_SEND;
	  mach_port_deallocate (mach_task_self (), rendezvous);
	}
      return err;
    }
}

/* Implement auth_server_authenticate as described in <hurd/auth.defs>. */
kern_return_t
S_auth_server_authenticate (struct authhandle *serverauth,
			    mach_port_t reply,
			    mach_msg_type_name_t reply_type,
			    mach_port_t rendezvous,
			    mach_port_t newport,
			    mach_msg_type_name_t newport_type,
			    uid_t **euids,
			    size_t *neuids,
			    uid_t **auids,
			    size_t *nauids,
			    uid_t **egids,
			    size_t *negids,
			    uid_t **agids,
			    size_t *nagids)
{
  struct pending *u;
  struct authhandle *user;

  if (! serverauth)
    return EOPNOTSUPP;

  if (rendezvous == MACH_PORT_DEAD) /* Port died in transit.  */
    return EINVAL;

  mutex_lock (&pending_lock);

  /* Look for this port in the user list.  */
  u = hurd_ihash_find (&pending_users, rendezvous);
  if (u)
    {
      /* Remove it from the pending list.  */
      hurd_ihash_locp_remove (&pending_users, u->locp);

      /* Found it!  We must add a ref because the one held by the
	 user RPC might die as soon as we unlock pending_lock.  */
      user = u->user;
      ports_port_ref (user);

      /* Give the user the new port and wake the RPC up.  */
      u->passthrough = newport;

      condition_signal (&u->wakeup);
      mutex_unlock (&pending_lock);
    }
  else
    {
      /* No pending user RPC for this port.
	 Create a pending server RPC record.  */
      struct pending s;
      error_t err;

      err = hurd_ihash_add (&pending_servers, rendezvous, &s);
      if (! err)
	{
	  /* Store the new port and wait for the user RPC to wake us up.  */
	  s.passthrough = newport;
	  condition_init (&s.wakeup);
	  ports_interrupt_self_on_port_death (serverauth, rendezvous);
	  if (hurd_condition_wait (&s.wakeup, &pending_lock))
	    /* We were interrupted; remove our record.  */
	    {
	      hurd_ihash_locp_remove (&pending_servers, s.locp);
	      err = EINTR;
	    }
	}
      /* The user side has already removed S from the ihash table.  */
      mutex_unlock (&pending_lock);

      if (err)
	return err;

      /* The user RPC has set the port (with a ref) and signalled S.wakeup.  */
      user = s.user;
    }

  /* Extract the ids.  We must use a separate reply stub so
     we can deref the user auth handle after the reply uses its
     contents.  */
  auth_server_authenticate_reply (reply, reply_type, 0,
				  user->euids.ids, user->euids.num,
				  user->auids.ids, user->auids.num,
				  user->egids.ids, user->egids.num,
				  user->agids.ids, user->agids.num);
  ports_port_deref (user);
  mach_port_deallocate (mach_task_self (), rendezvous);
  return MIG_NO_REPLY;
}



static int
auth_demuxer (mach_msg_header_t *inp, mach_msg_header_t *outp)
{
  extern int auth_server (mach_msg_header_t *inp, mach_msg_header_t *outp);
  return (auth_server (inp, outp) ||
	  ports_interrupt_server (inp, outp) ||
	  ports_notify_server (inp, outp));
}

static mach_port_t forward_sigexc;

void
_hurdsig_fault_init (void)
{ 
  error_t err;
  struct i386_thread_state state;
  mach_port_t sigexc;

  /* Allocate a port to receive signal thread exceptions.
   *      We will move this receive right to the proc server.  */
  err = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE, &sigexc);
  assert_perror (err);      
  err = mach_port_allocate (mach_task_self (),
			    MACH_PORT_RIGHT_RECEIVE, &forward_sigexc);
  assert_perror (err);

  /* Allocate a port to receive the exception msgs forwarded
   *      from the proc server.  */
  err = mach_port_insert_right (mach_task_self (), sigexc,
				  sigexc, MACH_MSG_TYPE_MAKE_SEND);
  assert_perror (err);

  /* Set the queue limit for this port to just one.  The proc server will
   *      notice if we ever get a second exception while one remains queued and
   *           unreceived, and decide we are hopelessly buggy.  */
#ifdef MACH_PORT_RECEIVE_STATUS_COUNT
    {
      const mach_port_limits_t lim = { mpl_qlimit: 1 };
      assert (MACH_PORT_RECEIVE_STATUS_COUNT == sizeof lim / sizeof (natural_t));
      err = mach_port_set_attributes (mach_task_self (), forward_sigexc,
					MACH_PORT_RECEIVE_STATUS,
					(mach_port_info_t) &lim,
					MACH_PORT_RECEIVE_STATUS_COUNT);
    }
#else
  err = mach_port_set_qlimit (mach_task_self (), forward_sigexc, 1);
#endif
  assert_perror (err);

  /* This state will be restored when we fault.
   *      It runs the function above.  */
  memset (&state, 0, sizeof state);

#define PC eip
#define SP uesp
#define SYSRETURN eax

#define MACHINE_THREAD_STATE_FIX_NEW(ts) do { \
            asm ("mov %%cs, %w0" : "=q" ((ts)->cs)); \
            asm ("mov %%ds, %w0" : "=q" ((ts)->ds)); \
            asm ("mov %%es, %w0" : "=q" ((ts)->es)); \
            asm ("mov %%fs, %w0" : "=q" ((ts)->fs)); \
            asm ("mov %%gs, %w0" : "=q" ((ts)->gs)); \
} while(0)

#ifndef MACHINE_THREAD_STATE_SET_PC
#define MACHINE_THREAD_STATE_SET_PC(ts, pc) \
      ((ts)->PC = (unsigned long int) (pc))
#endif
#ifndef MACHINE_THREAD_STATE_SET_SP
#ifdef STACK_GROWTH_UP
#define MACHINE_THREAD_STATE_SET_SP(ts, stack, size) \
      ((ts)->SP = (unsigned long int) (stack))
#else
#define MACHINE_THREAD_STATE_SET_SP(ts, stack, size) \
      ((ts)->SP = (unsigned long int) (stack) + (size))
#endif
#endif

#define MACHINE_THREAD_STATE_FLAVOR     i386_REGS_SEGS_STATE
#define MACHINE_THREAD_STATE_COUNT      i386_THREAD_STATE_COUNT

  static char faultstack[1024];

  MACHINE_THREAD_STATE_FIX_NEW (&state);
  MACHINE_THREAD_STATE_SET_PC (&state, NULL);
//  MACHINE_THREAD_STATE_SET_PC (&state, faulted);
  MACHINE_THREAD_STATE_SET_SP (&state, faultstack, sizeof faultstack);

  err = __USEPORT
    (PROC,
     proc_handle_exceptions (port,
			       sigexc,
			       forward_sigexc, MACH_MSG_TYPE_MAKE_SEND,
			       MACHINE_THREAD_STATE_FLAVOR,
			       (natural_t *) &state,
			       MACHINE_THREAD_STATE_COUNT));
  assert_perror (err);

  /* Direct signal thread exceptions to the proc server.  */
//#ifdef THREAD_EXCEPTION_PORT
//  err = thread_set_special_port (_hurd_msgport_thread,
//				   THREAD_EXCEPTION_PORT, sigexc);
//#elif defined (EXC_MASK_ALL)
//  thread_set_exception_ports (_hurd_msgport_thread,
//				EXC_MASK_ALL & ~(EXC_MASK_SYSCALL
//						 | EXC_MASK_MACH_SYSCALL
//						 | EXC_MASK_RPC_ALERT),
//				sigexc,
//				EXCEPTION_STATE_IDENTITY,
//				MACHINE_THREAD_STATE);
//#else
//# error thread_set_exception_ports?
//#endif
//  mach_port_deallocate (mach_task_self (), sigexc);
//  assert_perror (err);
}

mach_port_t _hurd_msgport;
thread_t _hurd_sigthread;

void
_hurdsig_init (const int *intarray, size_t intarraysize)
{
  error_t err;
  vm_size_t stacksize;
  struct hurd_sigstate *ss;

//  __mutex_init (&_hurd_siglock);

  err = mach_port_allocate (mach_task_self (),
			      MACH_PORT_RIGHT_RECEIVE,
			      &_hurd_msgport);
  assert_perror (err);

  /* Make a send right to the signal port.  */
  err = mach_port_insert_right (mach_task_self (),
				  _hurd_msgport,
				  _hurd_msgport,
				  MACH_MSG_TYPE_MAKE_SEND);
  assert_perror (err);

  /* Initialize the main thread's signal state.  */
  ss = _hurd_self_sigstate ();

  /* Copy inherited values from our parent (or pre-exec process state)
   *      into the signal settings of the main thread.  */
  if (intarraysize > INIT_SIGMASK)
    ss->blocked = intarray[INIT_SIGMASK];
  if (intarraysize > INIT_SIGPENDING)
    ss->pending = intarray[INIT_SIGPENDING];
  if (intarraysize > INIT_SIGIGN && intarray[INIT_SIGIGN] != 0)
    {
      int signo;
      for (signo = 1; signo < NSIG; ++signo)
	if (intarray[INIT_SIGIGN] & __sigmask(signo))
	  ss->actions[signo].sa_handler = SIG_IGN;
    }
  /* Set the default thread to receive task-global signals
   *      to this one, the main (first) user thread.  */
  _hurd_sigthread = ss->thread;

  /* Start the signal thread listening on the message port.  */

  if (__hurd_threadvar_stack_mask == 0)
    {
      err = __thread_create (__mach_task_self (), &_hurd_msgport_thread);
      assert_perror (err);

      stacksize = __vm_page_size * 8; /* Small stack for signal thread.  */
      err = __mach_setup_thread (__mach_task_self (), _hurd_msgport_thread,
				 _hurd_msgport_receive,
				 (vm_address_t *) &__hurd_sigthread_stack_base,
				 &stacksize);
      assert_perror (err);
      err = __mach_setup_tls (_hurd_msgport_thread);
      assert_perror (err);

      __hurd_sigthread_stack_end = __hurd_sigthread_stack_base + stacksize;
      __hurd_sigthread_variables =
	malloc (__hurd_threadvar_max * sizeof (unsigned long int));
      if (__hurd_sigthread_variables == NULL)
	__libc_fatal ("hurd: Can't allocate threadvars for signal thread\n");
      memset (__hurd_sigthread_variables, 0,
	      __hurd_threadvar_max * sizeof (unsigned long int));

      /* Reinitialize the MiG support routines so they will use a per-thread
       *          variable for the cached reply port.  */
      __mig_init ((void *) __hurd_sigthread_stack_base);

      err = __thread_resume (_hurd_msgport_thread);
      assert_perror (err);
    }
  else
    {
      /* When cthreads is being used, we need to make the signal thread a
	 proper cthread.  Otherwise it cannot use mutex_lock et al, which
	 will be the cthreads versions.  Various of the message port RPC
	 handlers need to take locks, so we need to be able to call into
	 cthreads code and meet its assumptions about how our thread and
	 its stack are arranged.  Since cthreads puts it there anyway,
	 we'll let the signal thread's per-thread variables be found as for
	 any normal cthread, and just leave the magic __hurd_sigthread_*
	 values all zero so they'll be ignored.  */
#pragma weak cthread_fork
#pragma weak cthread_detach
      cthread_detach (cthread_fork ((cthread_fn_t) &_hurd_msgport_receive, 0));

      /* XXX We need the thread port for the signal thread further on
	 in this thread (see hurdfault.c:_hurdsigfault_init).
	 Therefore we block until _hurd_msgport_thread is initialized
	 by the newly created thread.  This really shouldn't be
	 necessary; we should be able to fetch the thread port for a
	 cthread from here.  */
      while (_hurd_msgport_thread == 0)
	__swtch_pri (0);
    }

  /* Receive exceptions on the signal port.  */
#ifdef TASK_EXCEPTION_PORT
  __task_set_special_port (__mach_task_self (),
			   TASK_EXCEPTION_PORT, _hurd_msgport);
#elif defined (EXC_MASK_ALL)
  __task_set_exception_ports (__mach_task_self (),
			      EXC_MASK_ALL & ~(EXC_MASK_SYSCALL
					       | EXC_MASK_MACH_SYSCALL
					       | EXC_MASK_RPC_ALERT),
			      _hurd_msgport,
			      EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);
#else
# error task_set_exception_port?
#endif

  /* Sanity check.  Any pending, unblocked signals should have been
     taken by our predecessor incarnation (i.e. parent or pre-exec state)
     before packing up our init ints.  This assert is last (not above)
     so that signal handling is all set up to handle the abort.  */
    assert ((ss->pending &~ ss->blocked) == 0);
}


void
_hurd_new_proc_init (char **argv,
		     const int *intarray, size_t intarraysize)
{
  mach_port_t oldmsg;
  struct hurd_userlink ulink;
  process_t procserver;

  /* Initialize the signal code; Mach exceptions will become signals.  */
  _hurdsig_init (intarray, intarraysize);

  /* The signal thread is now prepared to receive messages.
   * It is safe to give the port to the proc server.  */

  procserver = _hurd_port_get (&_hurd_ports[INIT_PORT_PROC], &ulink);

  /* Give the proc server our message port.  */
  __proc_setmsgport (procserver, _hurd_msgport, &oldmsg);
  if (oldmsg != MACH_PORT_NULL)
    /* Deallocate the old msg port we replaced.  */
    __mach_port_deallocate (__mach_task_self (), oldmsg);

  /* Tell the proc server where our args and environment are.  */
  __proc_set_arg_locations (procserver, (vm_address_t) argv, 0);

  _hurd_port_free (&_hurd_ports[INIT_PORT_PROC], &ulink, procserver);

  /* Initialize proc server-assisted fault recovery for the signal thread.  */
  _hurdsig_fault_init ();         

  /* Call other things which want to do some initialization.  These are not
   * on the _hurd_subinit hook because things there assume that things done
   * here, like _hurd_pid, are already initialized.  */
//  RUN_HOOK (_hurd_proc_subinit, ());
//  
//  /* XXX This code should probably be removed entirely at some point.  This
//   * conditional should make it reasonably usable with old gdb's for a
//   * while.  Eventually it probably makes most sense for the exec server to
//   * mask out EXEC_SIGTRAP so the debugged program is closer to not being
//   * able to tell it's being debugged.  */
//  if (!__sigisemptyset (&_hurdsig_traced)
//#ifdef EXEC_SIGTRAP
//      && !(_hurd_exec_flags & EXEC_SIGTRAP)
//#endif
//  )
//    /* This process is "traced", meaning it should stop on signals or exec.
//     * We are all set up now to handle signals.  Stop ourselves, to inform
//     * our parent (presumably a debugger) that the exec has completed.  */
//    __msg_sig_post (_hurd_msgport, SIGTRAP, 0, __mach_task_self ());
}


int
main (int argc, char **argv)
{
  error_t err;
  mach_port_t boot;
  process_t proc;
  mach_port_t hostpriv, masterdev;
  struct authhandle *firstauth;
  struct argp argp = { 0, 0, 0, "Hurd standard authentication server." };

  argp_parse (&argp, argc, argv, 0, 0, 0);

  auth_bucket = ports_create_bucket ();
  authhandle_portclass = ports_create_class (&destroy_authhandle, 0);

  /* Create the initial root auth handle.  */
  err = create_authhandle (&firstauth);
  assert_perror (err);
  idvec_add (&firstauth->euids, 0);
  idvec_add (&firstauth->auids, 0);
  idvec_add (&firstauth->auids, 0);
  idvec_merge (&firstauth->egids, &firstauth->euids);
  idvec_merge (&firstauth->agids, &firstauth->auids);

  /* Fetch our bootstrap port and contact the bootstrap filesystem.  */
  err = task_get_bootstrap_port (mach_task_self (), &boot);
  assert_perror (err);
  if (boot == MACH_PORT_NULL)
    error (2, 0, "auth server can only be run by init during boot");
  err = startup_authinit (boot, ports_get_right (firstauth),
			  MACH_MSG_TYPE_MAKE_SEND, &proc);
  if (err)
    error (2, err, "cannot contact init for bootstrap");

  /* Register ourselves with the proc server and then start signals.  */
  proc_getprivports (proc, &hostpriv, &masterdev);
  proc_register_version (proc, hostpriv, "auth", "", HURD_VERSION);
  mach_port_deallocate (mach_task_self (), masterdev);
  _hurd_port_set (&_hurd_ports[INIT_PORT_PROC], proc);
  _hurd_proc_init (argv, NULL, 0);

  /* Init knows intimately that we will be ready for messages
     as soon as this returns. */
  startup_essential_task (boot, mach_task_self (), MACH_PORT_NULL, "auth",
			  hostpriv);
  mach_port_deallocate (mach_task_self (), boot);
  mach_port_deallocate (mach_task_self (), hostpriv);

  /* Be a server.  */
  while (1)
    ports_manage_port_operations_multithread (auth_bucket,
					      auth_demuxer,
					      30 * 1000, 0, 0);
}
