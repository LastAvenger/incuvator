***************
*** 26,36 ****
  #include <device/net_status.h>
  #include <netinet/in.h>
  #include <string.h>
  #include <error.h>
  
  #include <linux/netdevice.h>
  #include <linux/etherdevice.h>
  #include <linux/if_arp.h>
  
  
  struct port_class *etherreadclass;
--- 26,39 ----
  #include <device/net_status.h>
  #include <netinet/in.h>
  #include <string.h>
+ #define _HACK_ERRNO_H
+ #include <errno.h>
  #include <error.h>
  
  #include <linux/netdevice.h>
  #include <linux/etherdevice.h>
  #include <linux/if_arp.h>
+ #include <device/bpf.h>
  
  
  struct port_class *etherreadclass;
***************
*** 68,82 ****
  {
  }
  
- static short ether_filter[] =
  {
- #ifdef NETF_IN
-   /* We have to tell the packet filtering code that we're interested in
-      incoming packets.  */
-   NETF_IN, /* Header.  */
- #endif
-   NETF_PUSHLIT | NETF_NOP,
-   1
  };
  static int ether_filter_len = sizeof (ether_filter) / sizeof (short);
  
--- 71,85 ----
  {
  }
  
+ /* The BPF instruction allows IP and ARP packets */
+ static struct bpf_insn ether_filter[] =
  {
+     {NETF_IN|NETF_BPF, /* Header. */ 0, 0, 0},
+     {40, 0, 0, 12},
+     {21, 1, 0, 2054},
+     {21, 0, 1, 2048},
+     {6, 0, 0, 1500},
+     {6, 0, 0, 0}
  };
  static int ether_filter_len = sizeof (ether_filter) / sizeof (short);
  
***************
*** 166,176 ****
  
    mach_port_set_qlimit (mach_task_self (), edev->readptname, MACH_PORT_QLIMIT_MAX);
  
-   err = get_privileged_ports (0, &master_device);
-   if (err)
-     error (2, err, "cannot get device master port");
  
-   err = device_open (master_device, D_WRITE | D_READ, dev->name, &edev->ether_port);
    mach_port_deallocate (mach_task_self (), master_device);
    if (err)
      error (2, err, "%s", dev->name);
--- 169,180 ----
  
    mach_port_set_qlimit (mach_task_self (), edev->readptname, MACH_PORT_QLIMIT_MAX);
  
+   /* The device name here is the path of a device file.  */
+   master_device = file_name_lookup (dev->name, 0, 0);
+   if (master_device == MACH_PORT_NULL)
+     error (2, errno, "file_name_lookup %s", dev->name);
  
+   err = device_open (master_device, D_WRITE | D_READ, "eth", &edev->ether_port);
    mach_port_deallocate (mach_task_self (), master_device);
    if (err)
      error (2, err, "%s", dev->name);
