--- dde/e1000e/netdev.c.orig	2012-02-24 03:45:47.000000000 +0000
+++ dde/e1000e/netdev.c	2012-02-24 03:45:52.000000000 +0000
@@ -5217,7 +5217,7 @@
  * e1000_init_module is the first routine called when the driver is
  * loaded. All it does is register with the PCI subsystem.
  **/
-static int __init e1000_init_module(void)
+static int __init e1000e_init_module(void)
 {
 	int ret;
 	printk(KERN_INFO "%s: Intel(R) PRO/1000 Network Driver - %s\n",
@@ -5230,7 +5230,7 @@
 				
 	return ret;
 }
-module_init(e1000_init_module);
+module_init(e1000e_init_module);
 
 /**
  * e1000_exit_module - Driver Exit Cleanup Routine
--- dde/phy/mdio_bus.c.orig	2012-02-26 00:14:07.000000000 +0000
+++ dde/phy/mdio_bus.c	2012-02-26 00:14:08.000000000 +0000
@@ -99,7 +99,7 @@
 	bus->dev.parent = bus->parent;
 	bus->dev.class = &mdio_bus_class;
 	bus->dev.groups = NULL;
-	dev_set_name(&bus->dev, bus->id);
+	dev_set_name(&bus->dev, "%s", bus->id);
 
 	err = device_register(&bus->dev);
 	if (err) {

commit 349124a00754129a5f1e43efa84733e364bf3749
Author: Figo.zhang <zhangtianfei@leadcoretech.com>
Date:   Mon Jun 7 21:13:22 2010 +0000

    net8139: fix a race at the end of NAPI
    
    fix a race at the end of NAPI complete processing, it had
    better do __napi_complete() first before re-enable interrupt.
    
    Signed-off-by:Figo.zhang <figo1802@gmail.com>
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/drivers/net/8139cp.c b/drivers/net/8139cp.c
index 9c14975..284a5f4 100644
--- dde/8139cp.c
+++ dde/8139cp.c
@@ -598,8 +598,8 @@ rx_next:
 			goto rx_status_loop;
 
 		spin_lock_irqsave(&cp->lock, flags);
-		cpw16_f(IntrMask, cp_intr_mask);
 		__netif_rx_complete(napi);
+		cpw16_f(IntrMask, cp_intr_mask);
 		spin_unlock_irqrestore(&cp->lock, flags);
 	}
 
diff --git a/drivers/net/8139too.c b/drivers/net/8139too.c
index 80cd074..97d8068 100644
--- dde/8139too.c
+++ dde/8139too.c
@@ -2089,8 +2089,8 @@ static int rtl8139_poll(struct napi_struct *napi, int budget)
 		 * again when we think we are done.
 		 */
 		spin_lock_irqsave(&tp->lock, flags);
-		RTL_W16_F(IntrMask, rtl8139_intr_mask);
 		__netif_rx_complete(napi);
+		RTL_W16_F(IntrMask, rtl8139_intr_mask);
 		spin_unlock_irqrestore(&tp->lock, flags);
 	}
 	spin_unlock(&tp->rx_lock);
--- dde/e1000/e1000_main.c
+++ dde/e1000/e1000_main.c
@@ -3759,6 +3759,21 @@ static irqreturn_t e1000_intr(int irq, void *data)
 	if (unlikely(test_bit(__E1000_DOWN, &adapter->flags)))
 		return IRQ_HANDLED;
 
+	if (unlikely(icr & E1000_ICR_RXO)) {
+		/* Receive Overrun */
+		u32 rctl;
+		int i;
+		rctl = er32(RCTL);
+		ew32(RCTL, rctl & ~E1000_RCTL_EN);
+		for (i = 0; i < adapter->num_rx_queues; i++) {
+			memset(adapter->rx_ring[i].desc, 0, adapter->rx_ring[i].size);
+			adapter->rx_ring[i].next_to_clean = 0;
+		}
+		ew32(RDH, 0);
+		ew32(RCTL, rctl);
+		adapter->netdev->stats.rx_fifo_errors++;
+	}
+
 	if (unlikely(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC))) {
 		hw->get_link_status = 1;
 		/* guard against interrupt when we're going down */
